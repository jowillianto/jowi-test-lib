module;

#include <format>
#include <string>

export module test_lib:data;
import :exception;

namespace test_lib {
  /**
   * @brief Holds the result to a test. This code is not compile time sadly.
  */
  struct TestResult {
    std::string message;
    std::string test_name;
    bool status;

    std::string get_print_result() const {
      return status ? 
        std::format("{}\nstatus\t:{}\n", test_name, "OK") : 
        std::format("{}\nstatus\t:{}\nerr\t:{}\n", test_name, "ERR", message);
    }
  };

  // Compile Time Polymorphism
  template<typename T>
  concept TestEntryC = requires ( const T& test) {
    {test.run_test()} -> std::same_as<TestResult>;
    {test.get_test_name()} -> std::convertible_to<std::string>;
  };
  

  // Functor Implementation
  template<std::invocable F>
  struct TestConfig{
    private:
      F _test_func;
      std::string _test_name;
      struct ConstructorParams {
        std::string test_name;
        F test_func;
      };
    public:
    TestConfig (ConstructorParams params) : 
      _test_name(std::move(params.test_name)),
      _test_func(std::move(params.test_func))
    {}

    const std::string& get_test_name() const {
      return _test_name;
    }

    TestResult run_test() const noexcept {
      try {
        _test_func();
        return TestResult{
          .message = std::format("{} is successful", get_test_name()), 
          .test_name = get_test_name(), 
          .status = true
        };
      } 
      catch (const FailAssertion& e) {
        return TestResult{
          .message = std::format("FailAssertion(msg : {})\n", e.what()),
          .test_name = get_test_name(),
          .status = false
        };
      }
      catch (const std::exception& e) {
        return TestResult{
          .message = std::format("{}(msg : {})\n", typeid(e).name(), e.what()),
          .test_name = get_test_name(),
          .status = false
        };
      }
    }
  };
}