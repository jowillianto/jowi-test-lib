module;

#include <format>
#include <array>
#include <string>
#include <future>

export module test_lib:data;
import :exception;
import :container;

namespace test_lib {
  /**
   * @brief Holds the result to a test. This code cannot be compile time. Since
   * test results are only known after running the test. 
  */
  struct TestResult {
    std::string message;
    std::string test_name;
    bool status;

    std::string get_print_result() const {
      return status ? 
        std::format("status\t:{}\n", "OK") : 
        std::format("status\t:{}\nerr\t:{}\n", "ERR", message);
    }
  };

  // Compile Time Polymorphism
  template<typename T>
  concept TestEntryC = requires ( const T& test) {
    {test.run_test()} -> std::same_as<TestResult>;
    {test.get_test_name()} -> std::convertible_to<std::string>;
  };

  template<class T, size_t test_count>
  concept TesterC = requires (const T& tester) {
    { tester.is_parallel() } -> std::same_as<bool>;
    { tester.progress_hook(std::declval<size_t>(), std::declval<size_t>())};
    { tester.get_test_name() } -> std::convertible_to<std::string>;
    {
      tester.recursive_run(
        std::declval<ThreadSafeContainer<size_t>& >(),
        std::declval<std::array<TestResult, test_count>& >()
      )
    };
    {
      tester.recursive_parallel_run(
        std::declval<ThreadSafeContainer<size_t>& >(),
        std::declval<std::array<std::future<TestResult> , test_count>& >()
      )
    };
    {
      tester.run_all()
    } -> std::same_as<std::array<TestResult, test_count> >;
    { T::test_count() } -> std::same_as<size_t>;
  };
  

  // Functor Implementation
  template<std::invocable F>
  struct TestConfig{
    private:
      F _test_func;
      std::string _test_name;
      struct ConstructorParams {
        std::string test_name;
        F test_func;
      };
    public:
    TestConfig (ConstructorParams params) : 
      _test_name(std::move(params.test_name)),
      _test_func(std::move(params.test_func))
    {}

    const std::string& get_test_name() const {
      return _test_name;
    }

    TestResult run_test() const noexcept {
      try {
        _test_func();
        return TestResult{
          .message = std::format("{} is successful", get_test_name()), 
          .test_name = get_test_name(), 
          .status = true
        };
      } 
      catch (const FailAssertion& e) {
        return TestResult{
          .message = std::format("FailAssertion(msg : {})\n", e.what()),
          .test_name = get_test_name(),
          .status = false
        };
      }
      catch (const std::exception& e) {
        return TestResult{
          .message = std::format("{}(msg : {})\n", typeid(e).name(), e.what()),
          .test_name = get_test_name(),
          .status = false
        };
      }
    }
  };
}