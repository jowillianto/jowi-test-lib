module;
#include <numeric>
#include <format>
#include <array>
#include <string>
#include <future>
#include <array>

export module test_lib:data;
import :exception;
import :container;

namespace test_lib {
  /**
   * @brief Holds the result to a test. This code cannot be compile time. Since
   * test results are only known after running the test. 
  */
  export struct TestResult {
    std::string message;
    std::string test_name;
    bool status;

    std::string get_print_result() const {
      return status ? 
        std::format("status\t:{}\n\n", "OK") : 
        std::format("status\t:{}\nerr\t:{}\n", "ERR", message);
    }
  };

  // Compile Time Polymorphism
  export template<typename T>
  concept TestEntryC = requires ( const T& test) {
    {test.run_test()} -> std::same_as<TestResult>;
    {test.get_test_name()} -> std::convertible_to<std::string>;
  };
  export template<size_t size>
  struct ResultList {
    std::array<TestResult, size> array;
    size_t error_count() const{
      return std::accumulate(
        array.begin(), array.end(), static_cast<size_t>(0),
        [](size_t prev, const TestResult& t){
          if (t.status) return prev;
          else return prev + 1;
        }
      );
    }
    size_t ok_count() const{
      return std::accumulate(
        array.begin(), array.end(), static_cast<size_t>(0),
        [](size_t prev, const TestResult& t){
          if (t.status) return prev + 1;
          else return prev;
        }
      );
    }
  };
  export template<class T, size_t test_count>
  concept TesterC = requires (const T& tester) {
    { tester.is_parallel() } -> std::same_as<bool>;
    { tester.progress_hook(std::declval<size_t>(), std::declval<size_t>())};
    { tester.get_test_name() } -> std::convertible_to<std::string>;
    {
      tester.recursive_run(
        std::declval<ThreadSafeContainer<size_t>& >(),
        std::declval<std::array<TestResult, test_count>& >()
      )
    };
    {
      tester.recursive_parallel_run(
        std::declval<ThreadSafeContainer<size_t>& >(),
        std::declval<std::array<std::future<TestResult> , test_count>& >()
      )
    };
    {
      tester.run_all()
    } -> std::same_as<ResultList<test_count> >;
    { T::test_count() } -> std::same_as<size_t>;
  };
  

  // Functor Implementation
  export template<std::invocable F>
  struct TestConfig{
    private:
      F _test_func;
      std::string _test_name;
      struct ConstructorParams {
        std::string test_name;
        F test_func;
      };
    public:
    TestConfig (ConstructorParams params) : 
      _test_name(std::move(params.test_name)),
      _test_func(std::move(params.test_func))
    {}

    const std::string& get_test_name() const {
      return _test_name;
    }

    TestResult run_test() const noexcept {
      try {
        _test_func();
        return TestResult{
          .message = std::format("{} is successful", get_test_name()), 
          .test_name = get_test_name(), 
          .status = true
        };
      } 
      catch (const FailAssertion& e) {
        return TestResult{
          .message = std::format("FailAssertion(msg : {})\n", e.what()),
          .test_name = get_test_name(),
          .status = false
        };
      }
      catch (const std::exception& e) {
        return TestResult{
          .message = std::format("{}(msg : {})\n", typeid(e).name(), e.what()),
          .test_name = get_test_name(),
          .status = false
        };
      }
    }
  };
}