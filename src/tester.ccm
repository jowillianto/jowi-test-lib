module;
#include <algorithm>
#include <format>
#include <future>
#include <iostream>
#include <utility>
export module test_lib:tester;
import :data;
import :exception;
import :container;

namespace test_lib {
  /**
   * @brief Tester class declaration. Specialize on this class to implement 
   * compile time test running.
   */
  export template <TestEntryC... Args> class Tester {};

  // Recursive Case
  template <TestEntryC T, TestEntryC... Args>
  class Tester<T, Args...> {
    using PrevTester = Tester<Args...>;
    T _test_entry;
    const PrevTester &_prev_tester;
    struct ConstructorParams {
      T test_entry;
      const PrevTester &prev_tester;
    };

  public:
    static consteval size_t test_count() noexcept {
      return 1 + sizeof...(Args);
    }
    /**
        Gets if the current Tester supports parallelism. 
        The data for this is defined in the base case
      */
    bool is_parallel() const noexcept {
      return _prev_tester.is_parallel();
    }
    /**
        Runs the progress hook. 
        Only the base class have the progress hook hence this call will 
        recurse until the base case.
      */
    void progress_hook(size_t progress, size_t test_count) const noexcept {
      _prev_tester.progress_hook(progress, test_count);
    }
    /**
        This will run the test recursively down. This will not create a progress
        counter and will only accept a progress counter from the uppermost part
      */
    template <size_t size = test_count()>
    void recursive_run(
      ThreadSafeContainer<size_t> &progress, std::array<TestResult, size> &array
    ) const noexcept {
      _prev_tester.recursive_run(progress, array);
      array.at(test_count() - 1) = _test_entry.run_test();
      progress.write([](size_t progress) { return progress + 1; });
      progress.read([this](size_t progress) { progress_hook(progress, size); });
    }
    const std::string &get_test_name() const {
      return _prev_tester.get_test_name();
    }
    /**
        This will run the test recursively and in parallel.
      */
    template <size_t size = test_count()>
    void recursive_parallel_run(
      ThreadSafeContainer<size_t> &progress,
      std::array<std::future<TestResult>, size> &array
    ) const noexcept {
      _prev_tester.recursive_parallel_run(progress, array);
      array.at(test_count() - 1) =
        std::async(std::launch::async, [this, &progress]() {
          TestResult result = _test_entry.run_test();
          progress.write([](size_t progress) { return progress + 1; });
          progress.read([this](size_t progress) {
            progress_hook(progress, size);
          });
          return result;
        });
    }
    Tester(ConstructorParams params) :
      _test_entry(std::move(params.test_entry)),
      _prev_tester(std::move(params.prev_tester)) {}
    template <std::invocable F>
    Tester<TestConfig<F>, T, Args...> add_test(std::string name, F test_func)
      const noexcept {
      return Tester<TestConfig<F>, T, Args...>{
        {.test_entry =
           TestConfig<F>{
             {.test_name = std::move(name), .test_func = std::move(test_func)}
           },
         .prev_tester = *this}
      };
    }
    ResultList<test_count()> run_all() const noexcept {
      ThreadSafeContainer<size_t> progress{0};
      ResultList<test_count()> results;
      progress.read([this](size_t progress) {
        progress_hook(progress, test_count());
      });
      if (!is_parallel()) {
        recursive_run(progress, results.array);
      } else {
        std::array<std::future<TestResult>, test_count()> futures;
        recursive_parallel_run(progress, futures);
        std::transform(
          futures.begin(),
          futures.end(),
          results.array.begin(),
          [](std::future<TestResult> &fut) { return fut.get(); }
        );
      }
      return results;
    }
  };
  // Base Case
  template <> class Tester<> {
    bool _run_in_parallel;
    std::string _test_name;
    void _print_progress(size_t progress, size_t test_count) const noexcept {
      std::cout << "Current Test Progress : ";
      std::cout << std::format("{} / {}\n", progress, test_count);
    }

  public:
    static consteval uint32_t test_count() noexcept{
      return 0;
    }
    Tester(
      std::string test_suite_name,
      std::function<void(size_t)> prog_hook,
      bool run_in_parallel = true,
      bool print_progress = true
    ) :
      _test_name(std::move(test_suite_name)) {
      _run_in_parallel = run_in_parallel;

      if (print_progress)
        progress_hook = [prog_hook, this](size_t progress, size_t test_count) {
          this->_print_progress(progress, test_count);
          prog_hook(progress);
        };
      else
        progress_hook = [prog_hook](size_t progress, size_t test_count) {
          prog_hook(progress);
        };
    }
    Tester(
      std::string test_suite_name,
      bool run_in_parallel = true,
      bool print_progress = true
    ) :
      _test_name(std::move(test_suite_name)) {
      _run_in_parallel = run_in_parallel;
      if (print_progress)
        progress_hook = [this](size_t progress, size_t test_count) {
          this->_print_progress(progress, test_count);
        };
      else
        progress_hook = [](size_t progress, size_t test_count) {};
    }
    const std::string &get_test_name() const {
      return _test_name;
    }
    std::function<void(size_t, size_t)> progress_hook;
    bool is_parallel() const noexcept {
      return _run_in_parallel;
    }
    template <size_t size>
    void recursive_run(
      ThreadSafeContainer<size_t> &progress, std::array<TestResult, size> &array
    ) const noexcept {}
    template <size_t size>
    void recursive_parallel_run(
      ThreadSafeContainer<size_t> &progress,
      std::array<std::future<TestResult>, size> &array
    ) const noexcept {}
    ResultList<0> run_all() {
      return ResultList<0>{
        .array = std::array<TestResult, 0>{}
      };
    }
    template <std::invocable F>
    Tester<TestConfig<F>> add_test(std::string name, F test_func)
      const noexcept {
      return Tester<TestConfig<F>>{
        {.test_entry =
           TestConfig<F>{
             {.test_name = std::move(name), .test_func = std::move(test_func)}
           },
         .prev_tester = *this}
      };
    }
  };
};